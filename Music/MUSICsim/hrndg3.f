*********************************************************************
* Return a random point (x1,x2,x3) distributed according to the contents 
*  of the 3D Matrix ff(,,) generated by the function "gaisser"
*********************************************************************
      Subroutine hrndg3(ff,ii,a1,b1,jj,a2,b2,kk,a3,b3,sum,x1,x2,x3,pro)
      implicit none
      real*8 gaisser
      EXTERNAL gaisser, d3_integral
      integer i,j,k,ii,jj,kk,flag_p(3),flag_bin(3), m,n,l
      real*8 an1,bn1,an2,bn2,an3,bn3
      real*8 abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum    ! for integer a bin
      real*8 a1,b1,a2,b2,a3,b3, x,y,z
      real*8 sum,sumbox1,binx,biny,binz,x1,x2,x3,pp
      real*8 sumbox2,binxn,binyn,binzn
      real vec(5),pro
      Real*8 ff(ii,jj,kk)
      Real*8 bb(100,20,20)
      
      logical first
      data first/.TRUE./
      data m,n,l/20,2,2/                         !   (change) !~~~~~~~~~~~~!  binning in bin

**********************************
      IF(FIRST) THEN
         first = .FALSE.
      binx=(b1-a1)/ii
      biny=(b2-a2)/jj
      binz=(b3-a3)/kk

*--> book the 3d matrix & do integral
**********************************
       sumbox1=0.d0
      print *,'*--> do integral !  ---   Start!!!   --- '
       do i=1,ii
        if(mod(i,200).eq.0) print*,'^^^',i,'   ','sumbox1: ',sumbox1
        do j=1,jj
         do k=1,kk
*----------------------
*--> calculate the bin integral
* Which is only need to calculate for one time
*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          bsum=0.d0
          abin1=a1 + binx*(i-1)
          bbin1=abin1 + binx
          abin2=a2 + biny*(j-1)
          bbin2=abin2 + biny
          abin3=a3 + binz*(k-1)
          bbin3=abin3 + binz
           if(abin1.gt.80)then
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               10,6,4)
           else if(abin1.gt.40)then
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               16,6,4)
           else if(abin1.gt.10)then
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               80,6,4)
           else if(abin1.gt.5)then
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               400,6,4)
           else if(abin1.gt.1)then
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               1600,6,4)
           else if(abin1.gt.0.6)then
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               12000,6,4)
           else
            call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3,bsum,
     &               80000,3,2)
           endif
*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
*----------------------
         sumbox1=bsum+sumbox1
         ff(i,j,k)=sumbox1
         enddo
        enddo
       enddo
      sum = sumbox1
      print *,'*--> do integral !  ---  Result!!!  --- ',sum,'hz'

       If (pro.gt.10.)then
        print *,'double precision !'
       Else
        print *,'single precision !'
       Endif
      ENDIF                        !   only once called

**********************************


*--> generate three variables according to the muon_flux(,,) 
**********************************
       call ranlux(vec,1)
       pp=vec(1)*sumbox1
      do i=1,ii
       do j=1,jj
        do k=1,kk
         if(ff(i,j,k).ge.pp) then
          flag_p(1)=i
          flag_p(2)=j
          flag_p(3)=k
          goto 17
         endif
        enddo
       enddo
      enddo 

*-> do above again in the selected bin
*    to get better precision
***************
17    IF (pro.gt.10.)then
       an1=a1 + binx*(flag_p(1)-1)
       bn1=an1 + binx
       an2=a2 + biny*(flag_p(2)-1)
       bn2=an2 + biny
       an3=a3 + binz*(flag_p(3)-1)
       bn3=an3 + binz
       binxn=binx/m
       binyn=biny/n
       binzn=binz/l

        sumbox2=0.d0
        do i=1,m
         do j=1,n
          do k=1,l
*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          bsum=0.d0
          abin1=an1 + binxn*(i-1)
          bbin1=abin1 + binxn
          abin2=an2 + binyn*(j-1)
          bbin2=abin2 + binyn
          abin3=an3 + binzn*(k-1)
          bbin3=abin3 + binzn
           call d3_integral(abin1,bbin1,abin2,bbin2,abin3,bbin3
     &               ,bsum,4,4,2)
*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
          sumbox2=bsum+sumbox2
          bb(i,j,k)=sumbox2
          enddo
         enddo
        enddo

        call ranlux(vec,1)
        pp=vec(1)*sumbox2
       do i=1,m
        do j=1,n
         do k=1,l
          if(bb(i,j,k).ge.pp) then
           flag_bin(1)=i
           flag_bin(2)=j
           flag_bin(3)=k
           goto 18
          endif
         enddo
        enddo
       enddo 

* Give three random numbers to get the (x1,x2,x3).
**********************************
18      call ranlux(vec,3)
        x1=an1+binxn*(flag_bin(1)-1) + binxn*vec(1)
        x2=an2+binyn*(flag_bin(2)-1) + binyn*vec(2)
        x3=an3+binzn*(flag_bin(3)-1) + binzn*vec(3)
 
      ELSE 
       call ranlux(vec,3)
        x1=a1+binx*(flag_p(1)-1) + binx*vec(1)
        x2=a2+biny*(flag_p(2)-1) + biny*vec(2)
        x3=a3+binz*(flag_p(3)-1) + binz*vec(3)    
      ENDIF
***************
 
*      print'("vec(4) : ",4f12.5)',(vec(i),i=1,4)
*       if (flag_p(1).gt.0)then
*        print'("flag_p : ",3i12)',(flag_p(i),i=1,3)
*        print'("coordi : ",3f12.3)',x1,x2,x3
*       endif
**********************************
      END


